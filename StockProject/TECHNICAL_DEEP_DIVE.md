# 💻 기술 면접 준비를 위한 프로젝트 심층 분석

**SK AX AI Native 개발자 채용 전형의 1차 직무(기술) 면접을 대비하여 Stock Dashboard 프로젝트의 기술 스택, 아키텍처, 코드 설계에 대해 심층적으로 분석하고 정리한 문서입니다.**

---

## 1. 프로젝트 아키텍처 및 설계 철학

### Q. 이 기술 스택(Vue + FastAPI)을 선택한 이유는 무엇인가요?

**답변 요약**: **빠른 개발 속도**와 **높은 성능**이라는 두 가지 목표를 모두 달성하기 위함이었습니다. Python의 풍부한 데이터 처리 생태계를 활용하면서도, FastAPI의 비동기 특성을 통해 실시간 API 요청을 효율적으로 처리하고 싶었습니다. 프론트엔드는 Vue 3의 Composition API를 통해 복잡한 상태 로직을 명확하게 관리하고, Vite의 빠른 빌드 시스템으로 개발 생산성을 극대화했습니다.

- **Backend (FastAPI)**:
  - **비동기 처리**: 한국투자증권 API와 같이 외부 네트워크 요청이 잦은 서비스에서 `async/await`를 통해 블로킹 없이 여러 요청을 동시에 처리할 수 있어 성능상 이점이 명확합니다.
  - **Pydantic**: 데이터 유효성 검사를 모델 레벨에서 자동으로 처리해주어 코드의 안정성과 가독성을 높여줍니다.
  - **자동 API 문서**: `/docs`를 통해 API 명세를 자동으로 생성해주어 프론트엔드와의 협업 및 테스트 효율을 크게 향상시킵니다.

- **Frontend (Vue.js)**:
  - **Composition API**: `StockDashboard.vue`와 같이 여러 비즈니스 로직(검색, 모달, API 호출 등)이 혼재된 복잡한 컴포넌트에서 관련 코드를 논리적으로 그룹화하여 유지보수성을 높였습니다.
  - **Vite**: Hot Module Replacement(HMR) 속도가 매우 빨라 코드 수정 시 거의 즉각적으로 변경 사항을 확인할 수 있어 개발 경험이 뛰어납니다.
  - **점진적 프레임워크**: 프로젝트의 요구사항에 맞춰 라우팅(Vue Router), 상태 관리(Pinia) 등을 유연하게 추가할 수 있는 구조가 마음에 들었습니다.

---

## 2. Backend 기술 심층 분석 (FastAPI)

### 2.1. FastAPI 프레임워크

- **기본 개념**: Python 3.7+의 표준 기능인 Type Hint를 기반으로 동작하는 고성능 비동기 웹 프레임워크입니다. ASGI(Asynchronous Server Gateway Interface)를 기반으로 하며, Starlette(웹 파트)과 Pydantic(데이터 파트)을 핵심 요소로 사용합니다.

- **코드의 장점**:
  - **직관적인 의존성 주입**: `Depends`를 사용하여 `get_db`, `get_current_user`와 같은 공통 로직을 라우터에서 쉽게 재사용할 수 있었습니다. 이는 코드 중복을 줄이고 테스트를 용이하게 만듭니다.
  - **명확한 경로 함수**: `@router.get`, `@router.post`와 같은 데코레이터를 사용하여 API 엔드포인트를 직관적으로 정의할 수 있었습니다.
  - **Pydantic 스키마 활용**: `schemas/` 폴더의 Pydantic 모델을 통해 요청/응답 데이터의 형식을 강제하여 런타임 에러를 사전에 방지하고, API의 신뢰성을 높였습니다.

- **발생할 수 있는 문제점 및 해결 방안**:
  - **문제점: 동기 함수로 인한 이벤트 루프 블로킹**: 만약 `async def`로 선언된 경로 함수 내에서 무거운 동기 I/O 작업(예: 파일 처리, 복잡한 계산)을 그대로 실행하면, 전체 이벤트 루프가 멈춰 서버 성능이 급격히 저하될 수 있습니다.
  - **해결 방안**: FastAPI는 이러한 동기 함수를 `def`로 선언하면, 내부적으로 별도의 스레드 풀에서 실행하여 이벤트 루프의 블로킹을 막아줍니다. 따라서 I/O 작업이 동기적일 수밖에 없다면 `async def`가 아닌 `def`로 경로 함수를 정의하는 것이 중요합니다.

### 2.2. SQLAlchemy (ORM)

- **기본 개념**: ORM(Object-Relational Mapping)은 데이터베이스의 테이블을 Python 객체처럼 다룰 수 있게 해주는 라이브러리입니다. SQL 쿼리를 직접 작성하는 대신, Python 코드로 데이터베이스를 조작하여 생산성과 안정성을 높입니다.

- **코드의 장점**:
  - **SQL 인젝션 방어**: 모든 쿼리가 ORM을 통해 파라미터화되므로 SQL 인젝션 공격에 대해 기본적으로 안전합니다.
  - **유지보수 용이성**: `database.py`에 정의된 모델(e.g., `User`, `Stock`)만 수정하면 되므로, 데이터베이스 스키마 변경에 유연하게 대처할 수 있습니다.

- **발생할 수 있는 문제점 및 해결 방안**:
  - **문제점: N+1 문제**: 예를 들어, 포트폴리오 목록을 조회한 뒤 각 항목에 연결된 `Stock` 정보를 얻기 위해 루프를 돌며 쿼리를 실행하면, (1 + N)개의 쿼리가 발생하여 성능이 저하될 수 있습니다.
  - **해결 방안**: SQLAlchemy의 `joinedload`나 `selectinload`와 같은 Eager Loading 옵션을 사용하여 초기 쿼리 시점에 연관된 데이터를 함께 JOIN해서 가져오면, 단 한 번의 쿼리로 모든 정보를 조회할 수 있습니다.
    ```python
    # 예시: N+1 문제 해결
    from sqlalchemy.orm import joinedload
    
    db.query(Portfolio).options(joinedload(Portfolio.stock)).filter(...)
    ```

### 2.3. JWT 인증 (`auth.py`)

- **기본 개념**: JSON Web Token(JWT)은 사용자 정보를 JSON 객체에 담아 암호화 서명을 적용한 토큰입니다. 서버는 세션을 유지할 필요 없이 토큰의 유효성만 검증하면 되므로, Stateless한 아키텍처에 적합합니다.

- **코드의 장점**:
  - **Stateless**: 서버에 사용자 세션 정보를 저장하지 않으므로, 서버를 여러 개로 확장(Scale-out)하더라도 인증 상태를 쉽게 유지할 수 있습니다.
  - **모듈화**: 인증 관련 로직(`hash_password`, `create_access_token` 등)을 `auth.py`에 모아두고, `auth_router.py`에서 이를 가져다 사용하여 역할과 책임을 명확히 분리했습니다.

- **발생할 수 있는 문제점 및 해결 방안**:
  - **문제점: 토큰 탈취 및 재사용**: 만약 Access Token이 중간에 탈취되면, 만료될 때까지 공격자가 해당 사용자의 권한을 계속 사용할 수 있습니다.
  - **해결 방안 1 (단기 토큰 + Refresh Token)**: Access Token의 유효기간을 15~60분으로 짧게 설정하고, 유효기간이 긴(예: 7일) Refresh Token을 추가로 발급합니다. Access Token이 만료되면 Refresh Token을 사용해 조용히 재발급받는 로직을 구현하여 보안성과 사용자 편의성을 모두 높일 수 있습니다.
  - **해결 방안 2 (토큰 블랙리스트)**: 사용자가 로그아웃할 때 해당 토큰을 Redis와 같은 빠른 저장소에 '무효화된 토큰'으로 등록합니다. 그리고 API 요청이 들어올 때마다 토큰이 블랙리스트에 있는지 확인하는 로직을 추가합니다. 이는 JWT의 Stateless 장점을 일부 희생하지만, 즉각적인 토큰 무효화가 가능해집니다.

---

## 3. Frontend 기술 심층 분석 (Vue.js)

### 3.1. Vue 3 & Composition API

- **기본 개념**: Vue 3부터 도입된 새로운 컴포넌트 작성 방식입니다. 기존의 Options API가 `data`, `methods`, `computed` 등으로 코드를 분산시켰다면, Composition API는 `setup` 함수 내에서 관련 있는 로직(상태, 함수, 감시자 등)을 하나의 함수 단위로 묶어 관리할 수 있게 해줍니다.

- **코드의 장점**:
  - **논리적 관심사 분리**: `StockDashboard.vue`에서 `handleSearch`, `handleStockSelect`, `handleLogout` 등 다양한 기능들이 존재하는데, Composition API를 사용하면 각 기능과 관련된 상태와 함수를 한 곳에 모아둘 수 있어 코드를 이해하고 수정하기가 훨씬 수월합니다.
  - **로직 재사용성**: `stores/auth.js`의 `useAuth` 함수가 좋은 예입니다. 인증과 관련된 모든 상태와 로직을 이 함수에 담아두고, `Login.vue`, `Register.vue`, `StockDashboard.vue` 등 여러 컴포넌트에서 `useAuth()` 호출 한 번으로 쉽게 재사용할 수 있습니다.

- **발생할 수 있는 문제점 및 해결 방안**:
  - **문제점: Prop Drilling**: 만약 컴포넌트 구조가 매우 깊어진다면, 최상위 컴포넌트의 데이터를 최하위 컴포넌트로 전달하기 위해 중간의 모든 컴포넌트가 `props`를 계속해서 넘겨줘야 하는 'Prop Drilling' 현상이 발생할 수 있습니다.
  - **해결 방안**: Vue의 `provide`와 `inject`를 사용하면, 상위 컴포넌트에서 데이터를 "제공(provide)"하고, 하위의 어떤 컴포넌트에서든 `props` 전달 없이 직접 "주입(inject)"받아 사용할 수 있습니다. 이는 Prop Drilling을 효과적으로 해결해 줍니다.

### 3.2. 상태 관리 (`stores/auth.js`)

- **기본 개념**: 여러 컴포넌트가 공유하는 전역 상태(예: 로그인한 사용자 정보)를 중앙에서 관리하는 패턴입니다. 이 프로젝트에서는 공식 상태 관리 라이브러리인 Pinia 대신, Composition API를 활용한 간단한 `useAuth` Composable 함수로 이를 구현했습니다.

- **코드의 장점**:
  - **가벼움**: 별도의 라이브러리 설치 없이 Vue의 기본 기능만으로 상태 관리를 구현하여 프로젝트의 복잡도를 낮췄습니다.
  - **직관성**: `ref`와 `computed`를 사용하여 반응형 상태를 만들고, 이를 조작하는 함수들을 함께 반환하는 구조는 매우 직관적이고 이해하기 쉽습니다.

- **발생할 수 있는 문제점 및 해결 방안**:
  - **문제점: 확장성 및 디버깅의 한계**: 현재는 인증 상태만 관리하지만, 만약 다크/라이트 모드 테마, 사용자 설정 등 더 많은 전역 상태가 필요해진다면 `useAuth`와 같은 파일이 점점 비대해지고 관리하기 어려워질 것입니다. 또한, Vue Devtools에서 상태 변화를 직관적으로 추적하기 어렵습니다.
  - **해결 방안**: 프로젝트가 더 복잡해진다면, 공식 라이브러리인 **Pinia**로 마이그레이션하는 것이 좋습니다. Pinia는 각 스토어를 모듈 단위로 분리('stores' 개념)할 수 있게 해주고, Vue Devtools와의 완벽한 통합을 통해 상태 변화를 쉽게 디버깅할 수 있는 강력한 기능을 제공합니다.

### 3.3. API 통신 (Axios)

- **기본 개념**: 브라우저와 Node.js 환경에서 모두 사용할 수 있는 Promise 기반의 HTTP 클라이언트입니다. 비동기 데이터 요청을 간편하게 처리할 수 있게 해줍니다.

- **코드의 장점**:
  - **Promise 기반**: `async/await` 문법과 함께 사용하여 비동기 코드를 동기 코드처럼 깔끔하게 작성할 수 있었습니다.
  - **전역 설정**: `main.js` 또는 `stores/auth.js`에서 `axios.defaults.headers.common`을 설정하여, 모든 API 요청에 JWT 토큰을 자동으로 포함시킬 수 있습니다.

- **발생할 수 있는 문제점 및 해결 방안**:
  - **문제점: 반복적인 에러 처리 및 토큰 만료 로직**: 현재는 각 컴포넌트의 API 호출 부분에서 `try...catch` 블록을 사용하여 개별적으로 에러를 처리하고 있습니다. 특히 토큰 만료(401 Unauthorized) 시 사용자를 로그아웃시키는 로직이 여러 곳에 중복될 수 있습니다.
  - **해결 방안**: **Axios 인터셉터(Interceptor)**를 사용하면 이 문제를 중앙에서 해결할 수 있습니다. Response 인터셉터를 설정하여, 모든 API 응답을 받은 후에 특정 로직을 실행하도록 할 수 있습니다. 예를 들어, 응답 상태 코드가 401이면 `logout()` 함수를 호출하고 로그인 페이지로 리다이렉트시키는 로직을 인터셉터에 한 번만 작성하면, 모든 API 호출에 자동으로 적용됩니다.
    ```javascript
    // 예시: Axios 인터셉터 설정
    axios.interceptors.response.use(
      response => response,
      error => {
        if (error.response && error.response.status === 401) {
          // logout() 및 로그인 페이지로 리다이렉트
        }
        return Promise.reject(error);
      }
    );
    ```

---

## 4. Backend 코드 심층 분석 (File-by-File)

### `app.py`
- **역할**: FastAPI 애플리케이션의 진입점. 미들웨어(CORS), 라우터, lifespan 이벤트 등을 설정합니다.
- **주요 기술**: FastAPI Application, Lifespan, CORSMiddleware.
- **장점**:
    - **Lifespan 이벤트**: `@asynccontextmanager`를 사용하여 서버 시작 시점에 한국투자증권 API 토큰을 미리 발급받는 로직을 구현했습니다. 이는 첫 API 요청 시 발생할 수 있는 지연을 방지합니다.
    - **라우터 분리**: `app.include_router`를 통해 각 기능별 API를 별도의 파일로 분리하여 코드의 모듈성과 가독성을 높였습니다.
- **단점/문제점**:
    - **설정 하드코딩**: CORS 설정(`allow_origins`)이 `.env` 파일에서 문자열로 관리되고 있습니다. 더 복잡한 설정이 필요할 경우 유연성이 떨어질 수 있습니다.
    - **단일 파일**: 프로젝트가 더 커지면 `app.py`에 미들웨어나 이벤트 핸들러가 계속 추가되어 비대해질 수 있습니다.
- **개선 방안**:
    - **설정 구조화**: CORS 같은 복잡한 설정은 별도의 `config` 객체로 분리하여 관리하면 더 깔끔합니다.
    - **Application Factory 패턴**: `create_app`과 같은 함수를 만들어 앱 생성 로직을 캡슐화하면, 테스트나 다양한 환경 설정에 더 유연하게 대응할 수 있습니다.

### `database.py`
- **역할**: SQLAlchemy를 사용하여 데이터베이스 모델(테이블)을 정의하고, DB 세션 생성 로직을 관리합니다.
- **주요 기술**: SQLAlchemy ORM, `sessionmaker`.
- **장점**:
    - **관계 설정**: `relationship`을 사용하여 `User`, `Stock`, `Portfolio` 간의 관계를 명확하게 정의했습니다. `back_populates`를 통해 양방향 관계를 설정하여 객체 지향적으로 데이터를 탐색하기 용이합니다.
    - **세션 관리**: `get_db` 함수는 `yield`를 사용하여 API 요청마다 독립적인 DB 세션을 제공하고, 요청이 끝나면 자동으로 세션을 닫아주어 리소스 누수를 방지합니다.
- **단점/문제점**:
    - **마이그레이션 부재**: 현재는 `Base.metadata.create_all(bind=engine)`을 직접 실행하여 테이블을 생성합니다. 이는 개발 초기에는 편리하지만, 운영 환경에서 스키마 변경(예: 컬럼 추가)이 필요할 때 기존 데이터를 유지하면서 변경하기 어렵습니다.
- **개선 방안**:
    - **Alembic 도입**: SQLAlchemy의 공식 마이그레이션 도구인 `Alembic`을 도입해야 합니다. `alembic revision --autogenerate`와 같은 명령어를 통해 모델 변경 사항을 감지하고, 마이그레이션 스크립트를 자동으로 생성하여 안전하게 데이터베이스 스키마를 버전 관리할 수 있습니다.

### `services/korea_investment.py`
- **역할**: 한국투자증권 API와의 모든 통신을 담당하는 서비스 클래스. 토큰 관리, API 호출 등을 캡슐화합니다.
- **주요 기술**: `requests` 라이브러리, 클래스 기반 서비스 패턴.
- **장점**:
    - **캡슐화**: API 호출 로직이 이 클래스 안에 모두 모여있어, API 명세가 변경되거나 라이브러리를 교체해야 할 때 이 파일만 수정하면 됩니다.
    - **싱글톤 인스턴스**: `ki_service = KoreaInvestmentService()`와 같이 모듈 레벨에서 인스턴스를 생성하여, 애플리케이션 전체에서 단 하나의 인스턴스가 API 토큰을 관리하도록 했습니다. 이는 불필요한 토큰 재발급을 막아줍니다.
- **단점/문제점**:
    - **토큰 관리**: `access_token`을 클래스 인스턴스의 멤버 변수로만 저장합니다. 만약 서버가 여러 프로세스(Uvicorn workers)로 실행될 경우, 각 프로세스가 별도의 토큰을 발급받고 관리하게 되어 비효율적입니다.
    - **동기 방식**: `requests`는 동기 라이브러리입니다. FastAPI의 비동기 장점을 최대한 활용하려면 비동기 HTTP 클라이언트를 사용하는 것이 좋습니다.
- **개선 방안**:
    - **토큰 중앙 관리**: 토큰을 Redis와 같은 외부 공유 저장소에 저장하고, 만료 시간을 함께 기록하여 모든 프로세스가 동일한 토큰을 공유하도록 개선해야 합니다.
    - **비동기 HTTP 클라이언트**: `httpx`나 `aiohttp`와 같은 비동기 HTTP 클라이언트로 교체하고, 클래스의 모든 메서드를 `async def`로 변경하여 완전한 비동기 통신을 구현할 수 있습니다.

---

## 5. Frontend 코드 심층 분석 (File-by-File)

### `router/index.js`
- **역할**: Vue Router를 사용하여 페이지 라우팅 규칙과 네비게이션 가드를 정의합니다.
- **주요 기술**: Vue Router, Navigation Guards (`beforeEach`).
- **장점**:
    - **메타 필드 활용**: `meta: { requiresAuth: true }`와 같이 라우트 메타 필드를 활용하여 인증이 필요한 페이지를 선언적으로 관리합니다. 이는 가독성이 높고 유지보수가 용이합니다.
    - **중앙화된 인증 처리**: `beforeEach` 가드에서 모든 라우팅 요청을 가로채 인증 로직을 한 곳에서 처리하므로, 각 페이지 컴포넌트는 인증 상태에 대해 신경 쓸 필요가 없습니다.
- **단점/문제점**:
    - **Lazy Loading**: `component: Login`과 같이 컴포넌트를 직접 임포트하고 있습니다. 이 경우, 첫 페이지 로딩 시 사용되지 않는 페이지의 코드까지 모두 불러오게 되어 초기 로딩 속도가 느려집니다.
- **개선 방안**:
    - **동적 임포트(Dynamic Import)**: `component: () => import('../views/Login.vue')`와 같이 동적 임포트를 사용하면, 해당 라우트에 실제로 접근할 때만 컴포넌트의 코드를 불러오는 코드 스플리팅(Code Splitting)이 적용됩니다. 이를 통해 초기 번들 크기를 줄이고 로딩 성능을 크게 향상시킬 수 있습니다.

### `stores/auth.js`
- **역할**: Composition API를 활용하여 전역 인증 상태(사용자 정보, 토큰)와 관련 로직(로그인, 로그아웃 등)을 관리하는 Composable 함수를 제공합니다.
- **주요 기술**: Vue 3 `ref`, `computed`, Composition API.
- **장점**:
    - **단순함**: Pinia와 같은 외부 라이브러리 없이 Vue의 핵심 기능만으로 상태 관리를 구현하여 프로젝트의 복잡도를 낮췄습니다.
    - **자동 토큰 주입**: 로그인 성공 시 `axios.defaults.headers.common['Authorization']`을 설정하여, 이후 모든 API 요청에 자동으로 인증 헤더를 추가하는 로직이 포함되어 편리합니다.
- **단점/문제점**:
    - **반응성 한계**: `user` 객체 자체는 `ref`로 감싸여 있지만, 만약 `user.value.username = '새이름'`과 같이 객체 내부의 속성만 변경될 경우, 일부 상황에서 반응성 연결이 끊어질 수 있습니다.
    - **확장성 부재**: 전역 상태가 더 많아지면 이 파일 하나로 관리하기 복잡해집니다.
- **개선 방안**:
    - **`reactive` 사용**: `user`와 같은 객체 상태는 `ref` 대신 `reactive`로 선언하는 것이 더 적합합니다. `reactive`는 객체 내부의 모든 속성을 깊이 있게 반응형으로 만들어 줍니다.
    - **Pinia로 마이그레이션**: 프로젝트 규모가 커질 것을 대비하여 Pinia를 도입하면, 스토어를 모듈화하고 Devtools를 통한 디버깅을 용이하게 할 수 있습니다.

### `views/StockDashboard.vue`
- **역할**: 애플리케이션의 메인 페이지. 여러 하위 컴포넌트들을 조합하고, 이들 간의 데이터 흐름(이벤트)을 관리하는 오케스트레이터 역할을 합니다.
- **주요 기술**: Vue `ref`, `onMounted`, Props, Events.
- **장점**:
    - **컴포넌트 조합**: `StockSearch`, `TopStocks`, `PortfolioPanel` 등 각 기능별로 잘 분리된 컴포넌트들을 조합하여 복잡한 UI를 구성했습니다.
    - **이벤트 기반 통신**: 자식 컴포넌트(`TopStocks`)에서 발생한 `select` 이벤트를 부모(`StockDashboard`)가 받아 `handleStockSelect` 메서드를 실행하는 등, 명확한 이벤트 기반 통신 구조를 가집니다.
- **단점/문제점**:
    - **상태 관리의 중앙화 부재**: 현재 선택된 주식 정보(`currentStock`, `searchedCode`)가 `StockDashboard` 컴포넌트의 로컬 상태로 관리됩니다. 만약 다른 페이지에서도 이 정보가 필요하다면 상태를 공유하기 어렵습니다.
    - **Props/Events 복잡성**: `watchlist-updated` 이벤트가 발생하면, `StockDashboard`가 이를 받아 여러 자식 컴포넌트(`TopStocks`, `StockSearch`)의 메서드를 직접 호출(`ref.value.fetchWatchlist()`)하고 있습니다. 컴포넌트 구조가 더 복잡해지면 이러한 데이터 흐름이 얽히고 추적하기 어려워집니다.
- **개선 방안**:
    - **전역 상태 관리 도입**: 현재 선택된 주식 정보나 관심 종목 목록과 같은 여러 컴포넌트가 공유하는 상태는 Pinia 스토어로 옮겨 중앙에서 관리하는 것이 좋습니다. 이렇게 하면 어떤 컴포넌트에서든 스토어의 상태를 직접 구독하고, 액션을 통해 상태를 변경할 수 있어 데이터 흐름이 단순해집니다.

### `components/StockSearch.vue`
- **역할**: 사용자 입력을 받아 자동완성 검색 결과를 보여주고, 선택된 종목 정보를 부모 컴포넌트로 전달합니다.
- **주요 기술**: `setTimeout`을 이용한 Debouncing, 키보드 이벤트 핸들링.
- **장점**:
    - **성능 최적화 (Debouncing)**: `handleSearchInput` 함수 내에서 `setTimeout`을 사용하여, 사용자가 타이핑을 멈춘 후 300ms가 지나야만 API 요청을 보내도록 구현했습니다. 이는 불필요한 API 호출을 막아 서버 부하를 줄이고 사용자 경험을 향상시킵니다.
    - **사용자 경험**: 키보드 방향키(↑, ↓)와 Enter 키를 이용해 검색 결과를 탐색하고 선택할 수 있어 사용 편의성이 높습니다.
- **단점/문제점**:
    - **API URL 하드코딩**: `const API_BASE = 'http://localhost:8000/api'`와 같이 API 기본 주소가 컴포넌트 내에 하드코딩되어 있습니다. 만약 API 주소가 변경되면 여러 파일을 수정해야 합니다.
- **개선 방안**:
    - **환경 변수 사용**: Vite는 `.env` 파일을 통해 환경 변수를 지원합니다. `.env` 파일에 `VITE_API_BASE_URL=http://localhost:8000/api`와 같이 정의하고, 코드에서는 `import.meta.env.VITE_API_BASE_URL`로 참조하면, 환경별로 API 주소를 유연하게 변경할 수 있습니다.
    - **Axios 인스턴스 생성**: API 통신을 위한 전용 Axios 인스턴스를 생성하고 `baseURL`을 설정하면, 각 컴포넌트에서는 `/stocks/search`와 같이 상대 경로만으로 API를 호출할 수 있어 코드가 더 깔끔해집니다.